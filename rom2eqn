#!/usr/bin/env python3
# ROM to logic equation decoder
# Copyright 2018, 2021 Eric Smith <spacewar@gmail.com>
# SPDX-License-Identifier: GPL-3.0

# This program is free software: you can redistribute it and/or modify
# it under the terms of version 3 of the GNU General Public License
# as published by the Free Software Foundation.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from abc import ABC, abstractmethod
import argparse
from dataclasses import dataclass
from enum import Enum
import functools
import sys
from typing import Dict, List

from qm import QuineMcCluskey


class HDL_Language(Enum):
    VHDL = 1
    CUPL = 2

    @staticmethod
    def argparse(s):
        try:
            return HDL_Language[s.upper()]
        except KeyError:
            return s
    

def logic_minimize(data, bit_index):
    ones = []
    for addr in range(len(data)):
        if data[addr] & (1 << bit_index):
            ones += [addr]
    qm = QuineMcCluskey()
    return qm.simplify(ones = ones)


class PortDef:
    def __init__(self, infile, debug = False):
        self.addr_names = {}
        self.data_names = {}
        for l in infile:
            l = l.strip()
            if not l:
                continue
            if l[0] == '#':
                continue
            t = l.split()
            if (len(t) < 2):
                raise Exception('syntax')
            btype = t[0][0].lower()
            bnum = int(t[0][1:])
            if btype == 'a':
                if bnum in self.addr_names:
                    raise Exception(f'duplicate address bit {bnum}')
                self.addr_names[bnum] = t[1]
            elif btype == 'd':
                if bnum in self.data_names:
                    raise Exception(f'duplicate data bit {bnum}')
                self.data_names[bnum] = t[1]
        
        if not self.contiguous_range_from_zero(self.addr_names.keys()):
            raise Exception('address bits not contiguous from 0 to n-1')
        if not self.contiguous_range_from_zero(self.data_names.keys()):
            raise Exception('data bits not contiguous from 0 to n-1')

        if debug:
            print(f'addr width = {self.addr_width}', file = sys.stderr)
            print('addr_names:')
            for i in range(self.addr_width):
                print(f'{i}: {self.addr_names[i]}')
            print(f'data width = {self.data_width}', file = sys.stderr)
            print('data_names:')
            for i in range(self.data_width):
                print(f'{i}: {self.data_names[i]}')

    @staticmethod
    def contiguous_range_from_zero(l):
        return sorted(l) == list(range(len(l)))

    @property
    def addr_width(self):
        return len(self.addr_names)

    @property
    def data_width(self):
        return len(self.data_names)



@dataclass
class HDL(ABC):
    port_def: PortDef
    logic: List

    @abstractmethod
    def _decode_names (self, term):
        pass

    @abstractmethod
    def generate(self, outfile = sys.stdout):
        pass


class VHDL(HDL):
    entity_name: str = 'rom'
    architecture_name: str = 'rtl'
        
    def _decode_names(self, term):
        factors = []
        for i in range(len(term)):
            b = len(term) - 1 - i
            if term[i] == '-':
                continue
            elif term[i] == '0':
                factors.append(f'not {self.port_def.addr_names[b]}')
            elif term[i] == '1':
                factors.append(self.port_def.addr_names[b])
        return ' and '.join(factors)


    def generate(self, outfile = sys.stdout):
        p = functools.partial(print, file = outfile)
        p('library ieee;')
        p('use ieee.std_logic_1164.all;')
        p();
        p(f'entity {self.entity_name} is')
        p('  port (');
        for an in self.port_def.addr_names:
            p(f'    {self.port_def.addr_names[an]}: in  std_logic;');
        dn_list = [self.port_def.data_names[k] for k in sorted(self.port_def.data_names)]
        for dn in dn_list:
            if dn == dn_list[-1]:
                p(f'    {dn}: out std_logic ');
            else:
                p(f'    {dn}: out std_logic;');
        p('  );');
        p(f'end entity {self.entity_name};')
        p()
        p(f'architecture {self.architecture_name} of {self.entity_name} is')
        p('begin')
        p()
        for bit_index in range(len(self.port_def.data_names)):
            index = 0
            for term in self.logic[bit_index]:
                if index == 0:
                    p(f'  {self.port_def.data_names[bit_index]} <= ', end = '')
                else:
                    p((" " * (len(self.port_def.data_names[bit_index])+2)) + " or ", end = '')
                index += 1
                p('(' + self._decode_names(term) + ')', end = '')
                if index == len(self.logic[bit_index]):
                    p(';')
                else:
                    p()
            p()
        p(f'end architecture {self.architecture_name};')

        
class CUPL(HDL):
    def _decode_names(self, term):
        factors = []
        for i in range(len(term)):
            b = len(term) - 1 - i
            if term[i] == '-':
                continue
            elif term[i] == '0':
                factors.append(f'! {self.port_def.addr_names[b]}')
            elif term[i] == '1':
                factors.append(self.port_def.addr_names[b])
        return ' & '.join(factors)


    def generate(self, outfile = sys.stdout):
        ''' Note: does not generate the CUPL file header or pin definitions '''
        p = functools.partial(print, file = outfile)
        for bit_index in range(len(self.port_def.data_names)):
            index = 0
            for term in self.logic[bit_index]:
                if index == 0:
                    p(f'{self.port_def.data_names[bit_index]} = ', end = '')
                else:
                    p((' ' * (len(self.port_def.data_names[bit_index])+1)) + "# ", end = '')
                index += 1
                p(self._decode_names(term), end = '')
                if index == len(self.logic[bit_index]):
                    p(';')
                else:
                    p()
            p()


hdl_classes = { HDL_Language.VHDL: VHDL,
                HDL_Language.CUPL: CUPL }


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('devicefile',
                        type = argparse.FileType('r'),
                        help = 'device definition file')
    parser.add_argument('datafile',
                        type = argparse.FileType('rb'),
                        help = 'data file')
    parser.add_argument('-o', '--outfile',
                        type = argparse.FileType('w'),
                        default = sys.stdout)
    parser.add_argument('-l', '--language',
                        type = HDL_Language.argparse,
                        choices = list(HDL_Language),
                        default = HDL_Language.VHDL)
                        
                        
    args = parser.parse_args()

    port_def = PortDef(args.devicefile)
    
    data = args.datafile.read()

    logic = [logic_minimize(data, bit_index) for bit_index in range(port_def.data_width)]

    hdl = hdl_classes[args.language](port_def, logic)
    hdl.generate(outfile = args.outfile)

if __name__ == '__main__':
    main()
