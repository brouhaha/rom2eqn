#!/usr/bin/env python3
# ROM to logic equation decoder
# Copyright 2018, 2021 Eric Smith <spacewar@gmail.com>
# SPDX-License-Identifier: GPL-3.0

# This program is free software: you can redistribute it and/or modify
# it under the terms of version 3 of the GNU General Public License
# as published by the Free Software Foundation.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import argparse
from qm import QuineMcCluskey


def logic_minimize(data, bit_index):
    ones = []
    for addr in range(len(data)):
        if data[addr] & (1 << bit_index):
            ones += [addr]
    qm = QuineMcCluskey()
    return qm.simplify(ones = ones)


def parse_device_definition(f):
    addr_names = {}
    data_names = {}
    for l in f:
        l = l.strip()
        if not l:
            continue
        if l[0] == '#':
            continue
        t = l.split()
        if (len(t) < 2):
            raise Exception('syntax')
        btype = t[0][0].lower()
        bnum = int(t[0][1:])
        if btype == 'a':
            if bnum in addr_names:
                raise Exception('duplicate address bit %d' % bnum)
            addr_names[bnum] = t[1]
        elif btype == 'd':
            if bnum in data_names:
                raise Exception('duplicate data bit %d' % bnum)
            data_names[bnum] = t[1]
    return addr_names, data_names


def decode_names(term, data_names):
    factors = []
    for i in range(len(term)):
        b = len(term) - 1 - i
        if term[i] == '-':
            continue
        elif term[i] == '0':
            factors.append('not %s' % data_names[b])
        elif term[i] == '1':
            factors.append(data_names[b])
    return ' and '.join(factors)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('devicefile',
                        type = argparse.FileType('r'),
                        help = 'device definition file')
    parser.add_argument('datafile',
                        type = argparse.FileType('rb'),
                        help = 'data file')
    args = parser.parse_args()

    addr_names, data_names = parse_device_definition(args.devicefile)

    data = args.datafile.read()
    address_width = 10
    data_width = 4

    entity_name = 'foo';
    architecture_name = 'rtl';
    
    print('library ieee;')
    print('use ieee.std_logic_1164.all;')
    print();
    print('entity %s is' % entity_name)
    print('  port (');
    for an in addr_names:
        print('    %s: in  std_logic;' % addr_names[an]);
    dn_list = [data_names[k] for k in sorted(data_names)]
    for dn in dn_list:
        if dn == dn_list[-1]:
            print('    %s: out std_logic ' % dn);
        else:
            print('    %s: out std_logic;' % dn);
    print('  );');
    print('end entity %s;' % entity_name)
    print()
    print('architecture %s of %s is' % (architecture_name, entity_name))
    print('begin')
    print()
    for bit_index in range(data_width):
        sl = logic_minimize(data, bit_index)
        index = 0
        for term in sl:
            if index == 0:
                print('  %s <= ' % data_names[bit_index], end = '')
            else:
                print((" " * (len(data_names[bit_index])+2)) + " or ", end = '')
            index += 1
            print('(' + decode_names(term, addr_names) + ')', end = '')
            if index == len(sl):
                print(';')
            else:
                print()
        print()
    print('end architecture %s;' % architecture_name)


if __name__ == '__main__':
    main()
