#!/usr/bin/env python3
# ROM to logic equation decoder
# Copyright 2018, 2021 Eric Smith <spacewar@gmail.com>
# SPDX-License-Identifier: GPL-3.0

# This program is free software: you can redistribute it and/or modify
# it under the terms of version 3 of the GNU General Public License
# as published by the Free Software Foundation.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import argparse
from dataclasses import dataclass
import functools
import sys
from typing import Dict, List

from qm import QuineMcCluskey


def logic_minimize(data, bit_index):
    ones = []
    for addr in range(len(data)):
        if data[addr] & (1 << bit_index):
            ones += [addr]
    qm = QuineMcCluskey()
    return qm.simplify(ones = ones)


def parse_device_definition(f):
    addr_names = {}
    data_names = {}
    for l in f:
        l = l.strip()
        if not l:
            continue
        if l[0] == '#':
            continue
        t = l.split()
        if (len(t) < 2):
            raise Exception('syntax')
        btype = t[0][0].lower()
        bnum = int(t[0][1:])
        if btype == 'a':
            if bnum in addr_names:
                raise Exception('duplicate address bit %d' % bnum)
            addr_names[bnum] = t[1]
        elif btype == 'd':
            if bnum in data_names:
                raise Exception('duplicate data bit %d' % bnum)
            data_names[bnum] = t[1]
    return addr_names, data_names


def decode_names(term, data_names):
    factors = []
    for i in range(len(term)):
        b = len(term) - 1 - i
        if term[i] == '-':
            continue
        elif term[i] == '0':
            factors.append('not %s' % data_names[b])
        elif term[i] == '1':
            factors.append(data_names[b])
    return ' and '.join(factors)


@dataclass
class HDL:
    logic: List
    addr_names: Dict[int, str]
    data_names: Dict[int, str]


class VHDL(HDL):
    entity_name: str = 'rom'
    architecture_name: str = 'rtl'
        
    def generate(self, outf = sys.stdout):
        p = functools.partial(print, file = outf)
        p('library ieee;')
        p('use ieee.std_logic_1164.all;')
        p();
        p('entity %s is' % self.entity_name)
        p('  port (');
        for an in self.addr_names:
            p('    %s: in  std_logic;' % self.addr_names[an]);
        dn_list = [self.data_names[k] for k in sorted(self.data_names)]
        for dn in dn_list:
            if dn == dn_list[-1]:
                p('    %s: out std_logic ' % dn);
            else:
                p('    %s: out std_logic;' % dn);
        p('  );');
        p('end entity %s;' % self.entity_name)
        p()
        p('architecture %s of %s is' % (self.architecture_name, self.entity_name))
        p('begin')
        p()
        for bit_index in range(len(self.data_names)):
            index = 0
            for term in self.logic[bit_index]:
                if index == 0:
                    p('  %s <= ' % self.data_names[bit_index], end = '')
                else:
                    p((" " * (len(self.data_names[bit_index])+2)) + " or ", end = '')
                index += 1
                p('(' + decode_names(term, self.addr_names) + ')', end = '')
                if index == len(self.data_names) - 1:
                    p(';')
                else:
                    p()
            p()
        p('end architecture %s;' % self.architecture_name)

        
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('devicefile',
                        type = argparse.FileType('r'),
                        help = 'device definition file')
    parser.add_argument('datafile',
                        type = argparse.FileType('rb'),
                        help = 'data file')
    args = parser.parse_args()

    addr_names, data_names = parse_device_definition(args.devicefile)
    addr_width = len(addr_names)
    data_width = len(data_names)
    if False:
        print(f'addr width = {addr_width}', file = sys.stderr)
        print(f'data width = {data_width}', file = sys.stderr)
    
    data = args.datafile.read()

    logic = [logic_minimize(data, bit_index) for bit_index in range(data_width)]

    vhdl = VHDL(logic,
                addr_names,
                data_names)
    vhdl.generate()

if __name__ == '__main__':
    main()
